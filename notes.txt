RabbitMQ

Distributed Programming.

 Programs run on different runtimes and machines across network or local.

 Programs need to interact each other.

Why programms need to interact?
 Because they want to exchange some data(message).


Distributed architectures

1.main frame based

2.client-server

Apps --   Apps
 |          |
 os         os
  |         |
 server---client talks each other to exchange message
 RPI /RPC

SAME RUNTIME - SAME LANGUAGE

TEXIDO 

interoperable distributed programming

server and client can be anything

CORBA -  COmmon Object Request Broker Architecture - ORB
  was built up on object oriented modles : distributed object theory

Apps --     Apps
 |  objects |
 os         os
  |         |
 server---client 

SUN : ON java

RMI

EJB

Microsoft  : DCOM

Problems with Enterprise integration.

1.interprises are connected with different and different tech

Message Oriented Middlwares : MOM.

Client Apps send data(message) ----[MOM]--------Server Apps

RabbitMQ is one of the MOM product.

*****************************************************************************************

Style of Communication:
......................

1.Sync style
   Program1 on client A waits for Result of Program2 which is running Client 2

2.Async style
  Program1 on client A need not wait for Result of Program2 which is running Client 2

Ways to implement async
1.Messaging  :Async
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Distributed Messaging and standards:
...................................

Communication channels

Messaging Protocals standards are questions mark

1.reliable
2.security
3.performance


Messaging standards : AMQP 

AMQP is application level protocal, wire protocal is TCP /IP 

RabbitMQ is the first the reference implementation project built on AMQP.

appprotal
 |    
jdbc:mssql://host:port/dbname------driver----database
       |
       subprotocal

ampq:

RabbitMQ core concepts

Erlang provides runtime, called rabbitmq process.
Inside RabbitMq process, an web application has been deployed that is called as "VirtualHost"

Virtual host since is web app,  which has collection of objects.

 -Queue
    It is first in first out datastructure. but in rabbmitmq some times Queue works differently.
  so that we call "Weak Queue"

 -Exchange
   Built in broker /descision maker who decides how and where to deliver messages.


RabbitMQ installation on linux, windows:

Linux :
 - for administration

Windows :
-Development

Docker installation
 -dev and deployment

*****************************************************************************************

Linux :

setup file

#!/bin/sh

## If sudo is not available on the system,
## uncomment the line below to install it
# apt-get install -y sudo

sudo apt-get update -y

## Install prerequisites
sudo apt-get install curl gnupg -y

## Install RabbitMQ signing key
curl -fsSL https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc | sudo apt-key add -

## Install apt HTTPS transport
sudo apt-get install apt-transport-https

## Add Bintray repositories that provision latest RabbitMQ and Erlang 23.x releases
sudo tee /etc/apt/sources.list.d/bintray.rabbitmq.list <<EOF
## Installs the latest Erlang 23.x release.
## Change component to "erlang-22.x" to install the latest 22.x version.
## "bionic" as distribution name should work for any later Ubuntu or Debian release.
## See the release to distribution mapping table in RabbitMQ doc guides to learn more.
deb https://dl.bintray.com/rabbitmq-erlang/debian bionic erlang
## Installs latest RabbitMQ release
deb https://dl.bintray.com/rabbitmq/debian bionic main
EOF

## Update package indices
sudo apt-get update -y

## Install rabbitmq-server and its dependencies
sudo apt-get install rabbitmq-server -y --fix-missing

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Server status:

#!/bin/sh

## If sudo is not available on the system,
## uncomment the line below to install it
# apt-get install -y sudo

sudo apt-get update -y

## Install prerequisites
sudo apt-get install curl gnupg -y

## Install RabbitMQ signing key
curl -fsSL https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc | sudo apt-key add -

## Install apt HTTPS transport
sudo apt-get install apt-transport-https

## Add Bintray repositories that provision latest RabbitMQ and Erlang 23.x releases
sudo tee /etc/apt/sources.list.d/bintray.rabbitmq.list <<EOF
## Installs the latest Erlang 23.x release.
## Change component to "erlang-22.x" to install the latest 22.x version.
## "bionic" as distribution name should work for any later Ubuntu or Debian release.
## See the release to distribution mapping table in RabbitMQ doc guides to learn more.
deb https://dl.bintray.com/rabbitmq-erlang/debian bionic erlang
## Installs latest RabbitMQ release
deb https://dl.bintray.com/rabbitmq/debian bionic main
EOF

## Update package indices
sudo apt-get update -y

## Install rabbitmq-server and its dependencies
sudo apt-get install rabbitmq-server -y --fix-missing

*********************************************************************************************

After installing you can verfify the installation :


$sudo service rabbitmq-server status


Start,Stop,Restart the server:

There are two ways:

1.Using Linux operating commands

 $sudo service rabbitmq-server stop 
 $sudo service rabbitmq-server status
 $sudo service rabbitmq-server start
 $sudo service rabbitmq-server restart

2.Using rabbitmq provided cli command


******************************************************************************************

Rabbit MQ Boot Process:
.......................

$sudo rabbitmq-server start
          |
          loaded into main memory
               |
              Process(Erlang) is ready


 Since Rabbit Mq is server , which has default port 5672.

Rabbit MQ server mostly powered with configurations.


$sudo rabbitmq-server start
          |
          loaded into main memory
               |
              Process(Erlang) is ready
                |
                starts reading a configuration file
                        /etc/rabbitmq

Lab : 
1.Testing config files
  $ls -l /etc/rabbitmq

 by default there will be no files , empty


$sudo rabbitmq-server start
          |
          loaded into main memory
               |
              Process(Erlang) is ready
                |
                starts reading a configuration file
                        /etc/rabbitmq

Under this folder you can have three major configuration files, which need to be created
manually.

1.rabbitmq-env.conf

$sudo rabbitmq-server start
          |
          loaded into main memory
               |
              Process(Erlang) is ready
                |
                starts reading a configuration file
                        /etc/rabbitmq/rabbitmq-env.conf --entry file where major 
RabbitMQ configurations are found.

 But we have seen no such file , found. then how rabbit mq works.

    ->RabbitMQ has distributed default settings along with rabbitmq server.


The default Settings for RabbitMQ:

1.Node
   Node is logical representation machine,on which rabbitmq application are running
2.Port
   Node is running on default port is 5672
3.Default log file
   /var/log/rabbitmq

Lab verify log files

$ls -l /var/log/rabbitmq

 rabbit@ubuntu1-pc.log

$cat /var/log/rabbitmq/rabbit@ubuntu1-pc.log

 node           : rabbit@ubuntu1-pc
 home dir       : /var/lib/rabbitmq
 config file(s) : (none)
 cookie hash    : 3eMMjx9QP5Aq/27WdoZmgA==
 log(s)         : /var/log/rabbitmq/rabbit@ubuntu1-pc.log
                : /var/log/rabbitmq/rabbit@ubuntu1-pc_upgrade.log
 database dir   : /var/lib/rabbitmq/mnesia/rabbit@ubuntu1-pc
 

Default Node name always "rabbit" and its port 5672

**********************************************************************************************

RabbitMQ server can be started in two mode

1.logger mode

note : if server is running already
 stop it
 $sudo service rabbitmq-server stop
 then
 $sudo rabbitmq-server

2.detached mode
  
  $sudo rabbitmq-server -detached
  
*********************************************************************************************
How to start multple rabbitmq server?

Condition :

1.Each server should run in different port
2.Each server must have unique name.


Solution :  

You have to supply node name and port no differntly when you start server.

RabbitMQ can be configured by using three configurations

1.The first way is to use the RabbitMQ environment variables that lie on the environment variables of the operating system.

2.the second way is through the configuration file provided by RabbitMQ.
   rabbitmq.conf

3.the last way is to use runtime parameters
   A special runtime parameters are supplied to rabbitmq server when server runnging.
 
RabbitMQ server provides tools /clis for controlling rabbitmq server.

1.rabbitmqctl 
 for service management and general operator tasks
2.rabbitmq-diagnostics
  for diagnostics and health checking
3.rabbitmq-plugins
  for plugin management
4.rabbitmq-queues 
   for maintenance tasks on queues, in particular quorum queues
5.rabbitmq-upgrade
  for maintenance tasks related to upgrades
6.rabbitmqadmin 
 for operator tasks over HTTP API


********************************************************************************************
Environment Variables:

 Environment variables are supplied by RabbitMQ-Built in.

Environment variables are configured 
         1.inside rabbitmq-env.conf file : static configuration
         2.during server startup via commandline.


common environment variables
*****************************

RABBITMQ_NODE_IP_ADDRESS:
	Change this if you only want to bind to one network interface. Binding to two or more interfaces can be set up in the configuration file.
	Default: an empty string, meaning "bind to all network interfaces".

RABBITMQ_NODE_PORT	
	Default: 5672.

RABBITMQ_NODENAME
	The node name should be unique per Erlang-node-and-machine combination. To run multiple nodes, see the clustering guide.
	Default:
	Unix*: rabbit@$HOSTNAME
	Windows: rabbit@%COMPUTERNAME%

RABBITMQ_CONFIG_FILE
	Main RabbitMQ config file path.

RABBITMQ_ADVANCED_CONFIG_FILE
	"Advanced" (Erlang term-based) RabbitMQ config file 

RABBITMQ_CONF_ENV_FILE
	Location of the file that contains environment variable definitions (without the RABBITMQ_ prefix).
   default
	Ubuntu and Debian: /etc/rabbitmq/rabbitmq-env.conf

RABBITMQ_MNESIA_BASE
	This base directory contains sub-directories for the RabbitMQ server's node database, message store and cluster state files, one for each node, unless RABBITMQ_MNESIA_DIR is set explicitly.

  default:
	Ubuntu and Debian packages: /var/lib/rabbitmq/mnesia/

RABBITMQ_MNESIA_DIR
	The directory where this RabbitMQ node's data is stored. This s a schema database, message stores, cluster member information and other persistent node state.

RABBITMQ_PLUGINS_DIR
	The list of directories where plugin archive files are located and extracted from. This is PATH-like variable, where different paths are separated by an OS-specific separator (: for Unix, ; for Windows). Plugins can be installed to any of the directories listed here. Must not contain any characters mentioned in the path restriction section.

	Ubuntu and Debian packages: /var/lib/rabbitmq/plugins

Lab:

Environment variables can be set using:

1.via file : rabbitmq-env.conf 

# Example rabbitmq-env.conf file entries. Note that the variables
# do not have the RABBITMQ_ prefix.
#
# Overrides node name
NODENAME=bunny@myhost

# Specifies new style config file location
CONFIG_FILE=/etc/rabbitmq/rabbitmq.conf

# Specifies advanced config file location
ADVANCED_CONFIG_FILE=/etc/rabbitmq/advanced.config



Lab:

 $ sudo vi  /etc/rabbitmq/rabbitmq-env.conf


Press i - insert mode

type 
NODENAME=SGENNODE-BNG

press escap key

press shift and :

:wq!

****************************************************************************************

Suppling node name and port via command line:

sudo RABBITMQ_NODE_PORT=5674 RABBITMQ_NODENAME=mynode-1 rabbitmq-server

********************************************************************************************

rabbitmq.conf:

rabbitmq server provides ready made template 


 $ sudo vi  /etc/rabbitmq/rabbitmq.conf

1.via file : rabbitmq-env.conf 

# Example rabbitmq-env.conf file entries. Note that the variables
# do not have the RABBITMQ_ prefix.
#
# Overrides node name
NODENAME=bunny@myhost

# Specifies new style config file location
CONFIG_FILE=/etc/rabbitmq/rabbitmq.conf

# Specifies advanced config file location
ADVANCED_CONFIG_FILE=/etc/rabbitmq/advanced.config


setting config file location via command line

sudo RABBITMQ_CONFIG_FILE=/bserver/rabbitmq/rabbitmq.conf RABBITMQ_NODE_PORT=5674
RABBITMQ_NODENAME=mynode-1 rabbitmq-server

********************************************************************************************
Rabbit Management Console:

WebApplication , used to monitor and adminstrator RabbitMQ servers.
Management Application we call as "Virutal Host".

First Time When you install , vhost not available, i need to install.

RabbitMQ plugins:

 It is utlity programs, which extends the functionality of rabbitmq core server.

rabbitmq-plugins list
rabbitmq-plugins enable plname
rabbitmq-plugins disable plname

The RabbitMQ management plugin provides an HTTP-based API for management and monitoring of RabbitMQ nodes and clusters, along with a browser-based UI and a command line tool

*******************************************************************************************

RabbitMQ Messaging Flow:

Queue :

 It is data structure , where you publish message, and consume consume.

Lab :

1.Create Queue

2.Publish message 

3.Consume Message


Queue Type:

1.Classic Queue
   Normal Queue , used to publish and consume message
2.Quorum Queue 
   Distributed Queue, will discuss with Cluster and High availablity

Type of Queue:
 1.Durable Queue
 2.Transient Queue

Auto Delete;
  Do you want to delete the queue once , one or all consumers connected and consumed.


What is an exchange?
What are routing keys and bindings? 
How are exchanges and queues associated with each other?
When should I use them and how?

Messages are not published directly to a queue. Instead, the producer sends messages to an exchange.

Exchanges are message routing agents, defined by the virtual host within RabbitMQ. 

 An exchange is responsible for routing the messages to different queues with the help of header attributes, bindings, and routing keys.

A binding is a "link" that you set up to bind a queue to an exchange.


The routing key is a message attribute the exchange looks at when deciding how to route the message to queues (depending on exchange type).

Exchange Types: Algorthim used by AMQP to route Messages to Queue
...................................................................

Direct Exchange

1.A direct exchange delivers messages to queues based on a message routing key
2.The routing key is a message attribute added to the message header by the producer
3.Think of the routing key as an "address" that the exchange is using to decide how to route the message
4.A message goes to the queue(s) with the binding key that exactly matches the routing key of the message.


1.create Exchange
  subu.directExchange
2.create Queues
   subu.directQueu1
   subu.directQueu2
3.setup binding
   go to exchange 
  Queue name : subu.directQueu1
  RoutingKey : gotoheaven

4.Publish Message ,
  tell routing key
  headers 
  Payload

5.Go to Queue
   select Queue where message was published
   GetMessage

********************************************************************************************
Note : there are default Exchanges
starts with amq.direct  - type direct.

demo.direct



Fanout Exchange

A fanout exchange copies and routes a received message to all queues that are bound to it regardless of routing keys or pattern matching as with direct and topic exchanges.

The keys provided will simply be ignored.

Lab:

create fanout exchange

create two or three queues

bind exchange with queue.

********************************************************************************************
Topic 
  one or many queues based on wild cards
  - .
  - *
  - #

1.Topic exchanges route messages to queues based on wildcard matches between the routing key and the routing pattern, which is specified by the queue binding. 

2.Messages are routed to one or many queues based on a matching between a message routing key and this pattern.

The routing key must be a list of words, delimited by a period (.).
 Examples are agreements.us and agreements.eu.stockholm which in this case identifies agreements that are set up for a company with offices in lots of different locations.

 The routing patterns may contain an asterisk (“*”) to match a word in a specific position of the routing key (e.g., a routing pattern of "agreements.*.*.b.*" only match routing keys where the first word is "agreements" and the fourth word is "b"). A pound symbol (“#”) indicates a match of zero or more words (e.g., a routing pattern of "agreements.eu.berlin.#" matches any routing keys beginning with "agreements.eu.berlin").

pattern : covid.*
 covid.news
 covid.medicine
 covid.death
 covid.toal
 covid.recovery

**********************************************************************************************
Programming with RabbitMQ:

AMQP has two spec

1.Server Spec
   How to create Servers

2.Client Spec
   How to create clients

Many language vendors have implemented AMQP client Specfication.

Spec implementation is available most of the main stream programming language.

Languages:
1.python
2.java and frameworks - Spring Framework
3.C# -
4.java Script : node.js
etc....

Producer : can be any language

consumer : can be any language.


Dev Tech:
.........

jdk
ecplise
node js
vs code
maven
RabbitMQ

RabbitMQ windows:
................

JAVA_HOME C:\Program Files\Java\jdk1.8.0_161
*********************************************************************************************

Steps:

1.create maven project

2.amqp client lib


Basic Objects to connect rabbitmq

Steps 1 : connect rabbitmq server

ConnectionFactory is interface having api to reprensent connection string.

ConnectionFactory factory =new ConnectionFactory();

Steps 2 : From the factory you have to open socket connection - ampq protocal---tcp/ip
// create /establish amqp protocal/tcpip connection
Connection connection = factory.newConnection();

// Get Channel(Single Session through which you send message)
 Channel channel = connection.createChannel();
// Communication with Exchange and Queues

Step 3:Communication with RabbitMQ Server

Exchanges and Queues

Roles:
1.Producer
2.Consumer

1.create exchange and queue and its binds  from the code itself.
1.1 you can publish message and later you can consumer.

2.You can publish message into exchange and queue which already.

Use case : Create Exchange, direct,durable

package com.sc.rabbit.client;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class RabbitClient1 {

	private static final String EXCHANGE_NAME = "scgenexchange";

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		// factory declation
		ConnectionFactory factory = new ConnectionFactory();
		String hostName = "localhost";
		int portNumber = 5672;
		factory.setHost(hostName);
		factory.setPort(portNumber);
//		factory.setVirtualHost(virtualHost);
//		factory.setUsername(username);
//		factory.setPassword(password);

		try {
			// create /establish amqp protocal/tcpip connection
			Connection connection = factory.newConnection();

			// Get Channel(Single Session through which you send message)
			Channel channel = connection.createChannel();
			// Communication with Exchange and Queues
			// create Exchange : type =direct , durable
			channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT,true);
			System.out.println(EXCHANGE_NAME + " Created!");

		} catch (IOException | TimeoutException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

}
////////////////////////////////////////////////////////////////////////////////////////////

Create Queue:


package com.sc.rabbit.client;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class RabbitClient2 {
	private static final String QUEUE_NAME = "scgenQ1";

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		// factory declation
		ConnectionFactory factory = new ConnectionFactory();
		String hostName = "localhost";
		int portNumber = 5672;
		factory.setHost(hostName);
		factory.setPort(portNumber);
//		factory.setVirtualHost(virtualHost);
//		factory.setUsername(username);
//		factory.setPassword(password);

		try {
			// create /establish amqp protocal/tcpip connection
			Connection connection = factory.newConnection();

			// Get Channel(Single Session through which you send message)
			Channel channel = connection.createChannel();
			// Communication with Exchange and Queues
			// create Queue :
			channel.queueDeclare(QUEUE_NAME, true, false, false, null);
			System.out.println(QUEUE_NAME + " Created!");

		} catch (IOException | TimeoutException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

}

********************************************************************************************

Create Exchange,Queue,Bind them together:
........................................

package com.sc.rabbit.client;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class RabbitClient3 {
	private static final String EXCHANGE_NAME = "scgenexchange";
	private static final String QUEUE_NAME = "scgenQ1";
	private static final String ROUTING_KEY = "";

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		// factory declation
		ConnectionFactory factory = new ConnectionFactory();
		String hostName = "localhost";
		int portNumber = 5672;
		factory.setHost(hostName);
		factory.setPort(portNumber);
//		factory.setVirtualHost(virtualHost);
//		factory.setUsername(username);
//		factory.setPassword(password);

		try {
			// create /establish amqp protocal/tcpip connection
			Connection connection = factory.newConnection();

			// Get Channel(Single Session through which you send message)
			Channel channel = connection.createChannel();
			// Communication with Exchange and Queues

			channel.exchangeDeclare(EXCHANGE_NAME, "fanout", true);

			// create Queue :
			channel.queueDeclare(QUEUE_NAME, true, true, false, null);

			// Binding
			channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY);

			System.out.println(QUEUE_NAME + EXCHANGE_NAME + " Binding  Created!");

		} catch (IOException | TimeoutException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

}
		
*********************************************************************************************
Create Exchange,Queue,Bind them together and publish Message			


package com.sc.rabbit.client;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class RabbiClient4 {
	private static final String EXCHANGE_NAME = "scgenexchange";
	private static final String QUEUE_NAME = "scgenQ2";
	private static final String ROUTING_KEY = "";

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		// factory declation
		ConnectionFactory factory = new ConnectionFactory();
		String hostName = "localhost";
		int portNumber = 5672;
		factory.setHost(hostName);
		factory.setPort(portNumber);
//		factory.setVirtualHost(virtualHost);
//		factory.setUsername(username);
//		factory.setPassword(password);

		try {
			// create /establish amqp protocal/tcpip connection
			Connection connection = factory.newConnection();

			// Get Channel(Single Session through which you send message)
			Channel channel = connection.createChannel();
			// Communication with Exchange and Queues

			channel.exchangeDeclare(EXCHANGE_NAME, "fanout", true);

			// create Queue :
			channel.queueDeclare(QUEUE_NAME, true, false, false, null);
			// Binding
			channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY);

			// Message
			String message = "Hello,RabbitMQ!";

			// Publishing Message
			channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, null, message.getBytes("UTF-8"));

			System.out.println(QUEUE_NAME + EXCHANGE_NAME + "Message has been Published");
			
			//connection.close();

		} catch (IOException | TimeoutException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

}
*********************************************************************************************

Async consumers: consumer never block your client apps because of incoming messages.

package com.sc.rabbit.client;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.DeliverCallback;

public class RabbitConsumer {

	private static final String QUEUE_NAME = "scgenQ2";
	private static final String ROUTING_KEY = "";

	public static void main(String[] args) {
		ConnectionFactory factory = new ConnectionFactory();
		String hostName = "localhost";
		int portNumber = 5672;
		factory.setHost(hostName);
		factory.setPort(portNumber);

		try {
			// create /establish amqp protocal/tcpip connection
			Connection connection = factory.newConnection();

			// Get Channel(Single Session through which you send message)
			Channel channel = connection.createChannel();
				System.out.println(" Waiting for Messages. If you want exit, you can Press CTRL+C");
			// Consume : Async programming : callbacks
			DeliverCallback deliverCallback = (ConsumerTag, delivery) -> {
				String message = new String(delivery.getBody(), "UTF-8");
				System.out.println("Got : " + message);
			};
			// pass the callback function to basicConsume
			//basicConsume(queueName,successCallback,failureCallback)
			channel.basicConsume(QUEUE_NAME, deliverCallback, ctag -> {
				System.out.println("Consumer canceld due to some reasons");
			});

		} catch (IOException | TimeoutException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}
**********************************************************************************************
Java Application is Producer and Node js is consumer:
....................................................


//impoer amqp client dependency

const amqp =  require("amqplib/callback_api");

//connect amqp
const connectionString = "amqp://localhost";
amqp.connect(connectionString,function(err,connection){

    if(err){
        throw err;
    }

    //QUeue Basic properties
   //create channel
   connection.createChannel(function(cherr,channel){
       if(cherr){
           throw err;
       }
       const QUEUE_NAME ='scgenQ2';
       channel.assertQueue(QUEUE_NAME,{
           durable : true
       });
       console.log(" Waiting for Messages. If you want exit, you can Press CTRL+C");

       //consume message
       channel.consume(QUEUE_NAME,function(message){
             console.log("Got ", message.content.toString())
       },{
           noAck:true
       });

   });


});
********************************************************************************************
NonBlocking,Resource insentive tasks,Async Tasks:
.................................................

Solutions:

1.Programming language such as javascript, java

2.Distributed Messaging Solutions like RabbitmQ,Redis,Kaffa....

Many Publisher / single Publisher
One Queue
Many Consumers(Workers)
Message Ack
Persistency
Durability
Fair Delivery - restirct how many messages given to a consumer
Round Robin delivery to many consumers






Publisher :
Task.js
var amqp = require('amqplib/callback_api');

amqp.connect('amqp://localhost', function(error0, connection) {
    if (error0) {
        throw error0;
    }
    connection.createChannel(function(error1, channel) {
        if (error1) {
            throw error1;
        }
        var queue = 'task_queue';
        var msg = process.argv.slice(2).join(' ') || "Hello World!";

        channel.assertQueue(queue, {
            durable: true
        });
        channel.sendToQueue(queue, Buffer.from(msg), {
            persistent: true
        });
        console.log(" [x] Sent '%s'", msg);
    });
    setTimeout(function() {
        connection.close();
        process.exit(0);
    }, 500);
});

************************************************************************************************
const amqp = require('amqplib/callback_api');
const cluster = require('cluster');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
    console.log(`Master ${process.pid} is running`);
  
    // Fork workers.
    for (let i = 0; i < numCPUs; i++) {
      //will spawn many processes.
      cluster.fork();
    }
  
    cluster.on('exit', (worker, code, signal) => {
      console.log(`worker ${worker.process.pid} died`);
    });
  } else {
    // Workers can share any TCP connection
    amqp.connect('amqp://localhost', function(error, connection) {
        connection.createChannel(function(error, channel) {
            var queue = 'task_queue';
    
            channel.assertQueue(queue, {
                durable: true
            });
            //give only one message to one worker
            channel.prefetch(1);
            console.log(`[${process.pid}] Waiting for messages in %s. To exit press CTRL+C`, queue);
            channel.consume(queue, function(msg) {
                var secs = msg.content.toString().split('.').length - 1;
                //console.log(`Worker ${process.pid} started`);

                console.log(`[${process.pid}] Received %s`, msg.content.toString());
                //Simultation of long running task.
                setTimeout(function() {
                    console.log(`${process.pid} done`);
                    //send ack to rabbitmq , in order to remove message
                    channel.ack(msg);
                }, secs * 1000);
            }, {
                noAck: false
            });
        });
    });
  
  }
********************************************************************************************
Types of Queue:

1.named Queue
   - every queue will be named manullay eg "demo.queue" "scgen.order"

2. server-named
 quareDeclare()

package com.sc.rabbit.client;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class RabbitClient5 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		// factory declation
		ConnectionFactory factory = new ConnectionFactory();
		String hostName = "localhost";
		int portNumber = 5672;
		factory.setHost(hostName);
		factory.setPort(portNumber);
//		factory.setVirtualHost(virtualHost);
//		factory.setUsername(username);
//		factory.setPassword(password);

		try {
			// create /establish amqp protocal/tcpip connection
			Connection connection = factory.newConnection();

			// Get Channel(Single Session through which you send message)
			Channel channel = connection.createChannel();
			// Communication with Exchange and Queues
			// create Queue :
			channel.queueDeclare();
			String QUEUE_NAME = channel.queueDeclare().getQueue();
			System.out.println(QUEUE_NAME + " Created!");

		} catch (IOException | TimeoutException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}
}
*********************************************************************************************
How to publish JSON as message to rabbit mq

in java json converters are

1.jackson
2.Gson


Producer , publishes json 

package com.sc.rabbit.client.json;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

import com.google.gson.Gson;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

interface JSONMessage {
	String toJSON();
}

//entity class
class Message implements JSONMessage {
	// data variables
	private int msgNo;
	private String from;
	private String to;
	private String header;
	private String content;

	// create GSON parser object
	private static Gson gson = new Gson();

	public int getMsgNo() {
		return msgNo;
	}

	public void setMsgNo(int msgNo) {
		this.msgNo = msgNo;
	}

	public String getFrom() {
		return from;
	}

	public void setFrom(String from) {
		this.from = from;
	}

	public String getTo() {
		return to;
	}

	public void setTo(String to) {
		this.to = to;
	}

	public String getHeader() {
		return header;
	}

	public void setHeader(String header) {
		this.header = header;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	// object to json
	@Override
	public String toJSON() {
		return gson.toJson(this);
	}

	// Json to Object
	public static Message fromJSON(String msg) {
		Gson gson = new Gson();
		return (Message) gson.fromJson(msg, Message.class);
	}

	@Override
	public String toString() {
		return "Message [msgNo=" + msgNo + ", from=" + from + ", to=" + to + ", header=" + header + ", content="
				+ content + "]";
	}

}

public class PublishJSON {

	private final static String QUEUE_NAME = "message1.queue";
	private final static String EXCHANGE_NAME = "message1.exchange";
	private static final String ROUTING_KEY = "";

	public static void main(String[] args) {
		ConnectionFactory factory = new ConnectionFactory();
		String hostName = "localhost";
		int portNumber = 5672;
		factory.setHost(hostName);
		factory.setPort(portNumber);

		try {
			Connection connection = factory.newConnection();

			Channel channel = connection.createChannel();

			channel.exchangeDeclare(EXCHANGE_NAME, "fanout", true);

			// create Queue :
			channel.queueDeclare(QUEUE_NAME, true, false, false, null);

			// Binding
			channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY);

			// Publishing JSON

			Message message = new Message();
			message.setFrom("Subramanian");
			message.setTo("John");
			message.setHeader("News From Me");
			message.setContent("Greetings from Rabbit");

			channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, null,message.toJSON().getBytes());

			System.out.println("Message Published");

		} catch (IOException | TimeoutException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}
}
**********************************************************************************************

Consumer Consumes json:
//import amqp client dependency

const amqp =  require("amqplib/callback_api");


//connect amqp
const connectionString = "amqp://localhost";
amqp.connect(connectionString,function(err,connection){

    if(err){
        throw err;
    }

    //QUeue Basic properties
   //create channel
   connection.createChannel(function(cherr,channel){
       if(cherr){
           throw err;
       }
       const QUEUE_NAME ='message1.queue';
       channel.assertQueue(QUEUE_NAME,{
           durable : true
       });
       console.log(" Waiting for Messages. If you want exit, you can Press CTRL+C");

       //consume message
       channel.consume(QUEUE_NAME,function(message){
             console.log("Got ", JSON.parse(message.content.toString()));
       },{
           noAck:true
       });

   });


});
*******************************************************************************************

Spring Boot Integration:
.......................

resources/application.properties
spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
javainuse.rabbitmq.exchange=javainuse.exchange
javainuse.rabbitmq.queue=javainuse.queue
javainuse.rabbitmq.routingkey=javainuse.routingkey


App.java
package com.scgen.amqp.spring;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class App {

	public static void main(String[] args) {
		SpringApplication.run(new Object[] { App.class }, args);
	}
}

Entity
package com.scgen.amqp.spring.enity;

import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;

@JsonIdentityInfo(generator = ObjectIdGenerators.IntSequenceGenerator.class, property = "@id", scope = Employee.class)
public class Employee {

	private String empName;
	private String empId;

	public String getEmpName() {
		return empName;
	}

	public void setEmpName(String empName) {
		this.empName = empName;
	}

	public String getEmpId() {
		return empId;
	}

	public void setEmpId(String empId) {
		this.empId = empId;
	}

	@Override
	public String toString() {
		return "Employee [empName=" + empName + ", empId=" + empId + "]";
	}

}

Configuration
package com.scgen.amqp.spring.config;

import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.DirectExchange;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.amqp.support.converter.MessageConverter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitMQConfig {

	@Value("${javainuse.rabbitmq.queue}")
	String queueName;

	@Value("${javainuse.rabbitmq.exchange}")
	String exchange;

	@Value("${javainuse.rabbitmq.routingkey}")
	private String routingkey;

	@Bean
	Queue queue() {
		return new Queue(queueName, false);
	}

	@Bean
	DirectExchange exchange() {
		return new DirectExchange(exchange);
	}

	@Bean
	Binding binding(Queue queue, DirectExchange exchange) {
		return BindingBuilder.bind(queue).to(exchange).with(routingkey);
	}

	@Bean
	public MessageConverter jsonMessageConverter() {
		return new Jackson2JsonMessageConverter();
	}

	public AmqpTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
		final RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
		rabbitTemplate.setMessageConverter(jsonMessageConverter());
		return rabbitTemplate;
	}
}

Controller
package com.scgen.amqp.spring;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.scgen.amqp.spring.enity.Employee;
import com.scgen.amqp.spring.service.RabbitMQSender;

@RestController
@RequestMapping(value = "/scgen/")
public class RabbitMQWebController {

	@Autowired
	RabbitMQSender rabbitMQSender;

	@GetMapping(value = "/producer")
	public String producer(@RequestParam("empName") String empName, @RequestParam("empId") String empId) {

		Employee emp = new Employee();
		emp.setEmpId(empId);
		emp.setEmpName(empName);
		rabbitMQSender.send(emp);

		return "Message sent to the RabbitMQ JavaInUse Successfully";
	}

}

Sender:
package com.scgen.amqp.spring.service;

import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import com.scgen.amqp.spring.enity.Employee;


@Service
public class RabbitMQSender {
	
	@Autowired
	private AmqpTemplate amqpTemplate;
	
	@Value("${javainuse.rabbitmq.exchange}")
	private String exchange;
	
	@Value("${javainuse.rabbitmq.routingkey}")
	private String routingkey;	
	
	public void send(Employee company) {
		amqpTemplate.convertAndSend(exchange, routingkey, company);
		System.out.println("Send msg = " + company);
	    
	}
}

*********************************************************************************************

application.properties
spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
javainuse.rabbitmq.queue=javainuse.queue
server.port=8081

Spring Boot as Consumer
package com.scgen.amqp;

import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;

@SpringBootApplication
public class ClientApp {

	public static void main(String[] args) {
		SpringApplication.run(ClientApp.class, args);
		System.out.println("Client App is ready");
	}

	@Bean
	public Jackson2JsonMessageConverter converter() {
		return new Jackson2JsonMessageConverter();
	}
}


Consumer:
package com.scgen.amqp.spring.service;

import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

import com.scgen.amqp.spring.enity.Employee;


@Component
public class RabbitMQConsumer {

	@RabbitListener(queues = "${javainuse.rabbitmq.queue}")
	public void recievedMessage(Employee employee) {
		System.out.println("Recieved Message From RabbitMQ: " + employee);
	}
}

Entity;
package com.scgen.amqp.spring.enity;

public class Employee {

	private String empName;
	private String empId;

	public String getEmpName() {
		return empName;
	}

	public void setEmpName(String empName) {
		this.empName = empName;
	}

	public String getEmpId() {
		return empId;
	}

	public void setEmpId(String empId) {
		this.empId = empId;
	}

	@Override
	public String toString() {
		return "Employee [empName=" + empName + ", empId=" + empId + "]";
	}

}
**********************************************************************************************

Distributed RabbitMQ:
 
Distributing Queues and Exchanges across the nodes(Node-Single RabbitMQ Process).

Servers and Services  can be available

1.standalone mode
   single process , having all resources
2.Distributed mode
  multiple process, resources are shared

Resources in rabbit MQ:
Exchange
Queue
Virtualhost
Users and Permissions -  Auth and authorzation-  security.

Replication :
  Sharing the same of the resources across multiple process.
 
How we can distribute the RabbitMQ resources?

We have three patterns

1.Clustering
2.Federation
3.Shavel Plugin.

**********************************************************************************************

What is RabbitMQ cluster?

 A RabbitMQ cluster is logical grouping of one or serveral nodes , each sharing resources and talks each other.


Communication happens in general at very low level, protocal level.

Cluster Formation Requirement:
..............................

1.Erlang runtimes are communicating via exchanging a cookie Which is having secrete identifier.

 RB1-----sends a cookie--------cookie-RB2

            cookie file
/var/lib/rabbitmq/.erlang.cookie

2.HOSTNAME resolutions
 
 Rabbit MQ nodes are talking each other via by resolution of host names.

Lab :
 The verification of status of  running node.

 $sudo rabbitmqctl status

 ->Will return the default node sttaus

if i want to verify the other nodes status

 $sudo rabbitmqctl --node node@hostname status
 
 $sudo rabbitmqctl --node node@ubuntu2-pc status


3.PORT Access
 Three ports assigned for a node
 
1.port 15672
   It is used for management application - web interface

2.port 5672 
   It is used by AMQP Clients - java,javascript,c#.

3.port 25672
   It is a port assigned by rabbitmq for inter node communication : clustering

....ports are avaiable for other purposes.


4.Node types

1.RAM node
  RAM nodes store internal databse tables in RAM only
   database includes message,store index, quex, other node state(cluster node)
2.DISK node
 DISK nodes store internal databse tables in disk.
   database includes message,store index, quex, other node state(cluster node)

*********************************************************************************************

Lab : setup local cluster:
..........................

Note : 

 if managment plugin is enabled , first you have to disable it. when you do first time
cluster formation.

Why :
  Even though nodes are different, plugins are shared by all nodes.

 rabbitmq-plugins disable rabbitmq_management
*********************************************************************************************
Note : 

 if you are starting two nodes togethers with different port and node name.

1. Ensure that any one server is running already
  
    Stop server's application. not server.

 if it is default rabbit server /any server name
 
 $sudo rabbitmqctl stop_app
    To accessing plugins.



1. From a root shell (Linux), start a second RabbitMQ instance with the following
command:
sudo RABBITMQ_NODENAME=node01 RABBITMQ_NODE_PORT=5673 RABBITMQ_
SERVER_START_ARGS="-rabbitmq_management listener [{port,15673}]"
rabbitmq-server -detached

2. Join this instance to the default one with the following commands:

rabbitmqctl -n node01@hostname stop_app
rabbitmqctl -n node01 join_cluster rabbit@HOSTNAME
rabbitmqctl -n node01 start_app


3. Check your running cluster with the following command:

rabbitmqctl cluster_status

4. Break the cluster back into individual nodes with the following commands:
rabbitmqctl -n node01 stop_app
rabbitmqctl -n node01 reset
rabbitmqctl -n node01 start_app


*********************************************************************************************

High Availability : scallaing RabbitMQ across node.

Queues you can scale across node.

Queue Mirroring:
................
Replication of Queus across the nodes.

Consumer-----------|

Quorum Queue : HA Queues 

Master Node , Slave Node

if master dies, any one of the slave in the cluster becomes master so on...
  

High Availability:
 Whilst RabbitMQ  supports clustering, clustering is intended to facilitate scalability, not availability. Thus in a cluster, if a node fails, queues which were on the failed node are lost. With the high availability setup described in this guide, when a node fails, the durable queues and the persistent messages within them can be recovered by a different node


Why?
RabbitMQ approaches the issue of high availability by replicating data, the same as storage solutions (think of the RAID solutions), databases, and all the IT infrastructures when data integrity and service continuity are of primary importance.

In fact, the objective of these kinds of solutions is not only to avoid the possibility of data loss but also to avoid any downtime due to both scheduled maintenance and system malfunctions

Mirroring queues:

Lab :

Requirement:

1.You must have a cluster.



Starting:

In order to configure a mirror queue, there are two ways that can be used; that is, it can be
configured using rabbitmqctl or using the web management plugin

1.setup cluster, within host.


2. Configure the policies via web management by navigating to Admin | Policies | Add
/ update a policy.

3. Enter mirror-all to the Name field, ^mirr\. to the Pattern field, and ha-mode
and all to the Definition field

Mirroring queues:

Lab :

Requirement:

1.You must have a cluster.


Starting:

In order to configure a mirror queue, there are two ways that can be used; that is, it can be
configured using rabbitmqctl or using the web management plugin

1.setup cluster, within host or across vms.


2. Configure the policies via web management by navigating to Admin | Policies | Add
/ update a policy.

3. Enter mirror-all to the Name field, ^mirr\. to the Pattern field, and ha-mode
and all to the Definition field
  

4. Click on Add policy.

please refer:mirror-lab1.jpg


5.Create a queue named mirr.q_connection_1_1. (It's important that the prefix is
mirr.; you are free to call the queue as you prefer.)


Refer Mirroring in the management :mirror-lab2.png

The mirror-all parameter is the policy name, and the ^mirr\. string is the regular
expression pattern. We are instructing RabbitMQ to mirror all the queues that have names
starting with mirr..

The last parameter is the mirroring mode. With ha-mode:all, the queues are mirrored
across all the nodes in the cluster using a master slave pattern (the slaves can be more than
one). Whenever a queue matches the given pattern is created on one node, it is replicated on
all the others, and whenever a client starts inserting messages in it, they are replicated across all the slaves.


Distributing messages between a couple of brokers:
..................................................

The ha-mirror plugin requires a cluster.

In order to replicate messages across the WAN, you can use the federation plugin. This plugin
does not require a cluster, so you can federate more RabbitMQ instances over a WAN even
with different Erlang versions.



Two machines

1.chennaiserver
10.0.2.9
2.banagloreserver
10.0.2.16


Upstream Server : Chennai Server
downstream Server : Banaglore Server


The federation plugin must be enabled; it's disabled by default. For both the machines,
perform the following steps:

1. Enable the plugin using the following command:

 rabbitmq-plugins enable rabbitmq_federation

2. Enable the plugin for the web management console using the following command:

 rabbitmq-plugins enable rabbitmq_federation_management


3. Restart RabbitMQ and check the plugin using rabbitmqctlstatus, as you can see
in the following screenshot:

For rabbitmqc1 machine, perform the following steps:

4. It's also possible to check the status on the web management. On selecting the
Admin tab, you can see the Federation Status and Federation Upstreams entries on
the right, as shown in the following screenshot:

Federation-admin.jpg




Note: 

In the DownStream server -banaglore-server
 
we cant use / vhost and guest user account

so

1.Add new vhost
 /bnghost
2.create new user
 subu
 subugee
 management
3.set permissions for subu and on bnghost and /


Go to chennai server
....................

1.Configure the federation upstreams. Open the web management console by
navigating to Admin | Federation Upstreams | Add a new upstream, and then fill
the following fields:

 Name: first_upstream
 URI: amqp://subu:subugee@banaglore-server/bnghost

2.For the Chennaiserver machine, configure the federation policy. Open the web
management console and navigate to Admin | Policies | Add / update a policy, and
fill the following fields:
 Name: fed_policy
 Pattern: ^fed\.
 Definition: federation-upstream-set:all

3.For the Chennaiserver machine, add a new exchange with the prefix fed., for example
fed.myfanoutexchange

4.For the chennaiserver machine, check the upstream status from the web
management console by navigating to Admin | Federation Status and if everything is
fine, you should have the following screenshot
.........................................................................................

Java Client Communication with RabbitMQ in cluster and HA mode


ConnectionFactory factory = new ConnectionFactory();


Address [] address = { new Address("host","port"),new Address("host","port")}
Connection connection = factory.newConnection(address);

connection.basicBasic()---->

*****************************************************************************************

Load Balancer

Consumer------------------|Load Balancer----|rabbitMQ instance
*********************************************************************************************

Ways to Configure RabbitMQServer : 

lets say policy configuration:

rabbitmqctl	
     rabbitmqctl set_policy ha-all "^ha\." '{"ha-mode":"all"}'


HTTP API	
PUT /api/policies/%2f/ha-all {"pattern":"^ha\.", "definition":{"ha-mode":"all"}}

Web UI	
Navigate to Admin > Policies > Add / update a policy.
Enter “ha-all” next to Name, “^ha.” next to Pattern, and “ha-mode” = “all” in the first line next to Policy.
Click Add policy.








 





